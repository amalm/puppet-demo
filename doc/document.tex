\documentclass[12pt,a4paper,ngerman]{article}
\include{header/general}
\include{header/listings}
\include{header/pagesetup}
\include{header/hyperref}
\include{header/commands}


\begin{document}
 \begin{titlepage}
     \begin{flushright}{\huge Deliver with Puppet}
	\end{flushright}
	\hrule
      
      \begin{flushright}
	  {\large Anders Malmborg und Michael Haslgrübler}\\
	  \today
	\end{flushright}
 \end{titlepage}

\pagestyle{plain}

\section{Einleitung}

\subsection{Ausgangssituation}

Eine prekäre Situation, eine mehrere Teams entwickeln, unabhängig voneinander mit agilen Methoden, eine Vielzahl von modularen Frameworks und Applikationen. Mithilfe von \cite{jenkins} wird stündlich kompiliert und integriert um sicherzustellen dass das alles auch zusammenpasst. 

Jede Applikation beinhaltet außerdem Konfigurationen, im banalsten Fall sind das Einstellungen für den Zugriff auf eine Datenbank, im komplexesten Fall Schalter welche Teilfunktionalitäten aktivieren. Die Installation und Konfiguration gestaltet sich aber mit zunehmender Größe der Applikation jedoch so komplex, dass das initiale Setup einer Applikation schon Stunden dauern kann, auch wenn schon eine handvoll Scripts einen Großteil der Tätigkeiten automatisierten. 

\begin{wrapfigure}{l}{5cm}
\vspace{-15pt}
\begin{boxedminipage}{5cm}
Eine Installation von der selben Anwendung sieht auf verschiedenen Maschinen unterschiedlich aus  - \textbf{frei nach dem Motto viele Wege führen nach Rom - aber welcher ist der Beste?}
\end{boxedminipage}
\vspace{-15pt}
\end{wrapfigure}
Man kann außerdem davon ausgehen, das die gleiche Installation von der selben Anwendung auf zwei Rechner unterschiedlich aussieht -- frei nach dem Motto viele Wege führen nach Rom. Zusätzlich dazu sind die Anwendungen im internationalen Einsatz, werden mehrsprachig getestet und betrieben und die laufende Entwicklung erweitert ständig die Funktionalität. 

Kurz zusammengefasst, Veränderungen passieren am laufenden Band. Für die reine Softwareentwicklung ist Continous Integration mit Jenkins und Co eine Toollandschaft entstanden welche das Problem löst. Für die Betriebsführung und Konfiguration haben wir uns nach einer Lösung umgesehen und mit \cite{puppet} und \cite{chef} Wege gefunden dieser ständigen Veränderung habhaft zu werden.

\subsection{Ziel}

Ziel unserer Lösung, für die Betriebsführung und Konfiguration, sollte es sein, die aktuellen Entwicklungen an den Mann bzw. Server zu bringen, vollautomatisiert. 
\begin{wrapfigure}{r}{5cm}
\vspace{-10pt}
\begin{boxedminipage}{5cm}
Konfigurationsfehler durch Divergenz werden in allen Stages des Softwarelifecycleprozesses durch die Vollautomatisierung vermieden - \textbf{entweder funktioniert es überall oder nirgends}
\end{boxedminipage}
\vspace{-10pt}
\end{wrapfigure}
 In der Entwicklung heißt das in erster Linie Softwarecode der commited wird, der gebaut werden kann und die automatisierten Tests besteht soll auch deployed werden. Damit können wir gewährleisten bzw. überprüfen das die Software zu jedem Zeitpunkt einsatzbereit ist und nicht nur auf einem Entwicklungs-PC funktioniert.

Für die Qualitätssicherung heißt das, dass ein Softwarepaket einer Anwendung bei Übergabe von der Entwicklung nur einmal zentral hinterlegt werden muss und alle QA Server in allen möglichen Konfigurationsarten und Sprachen automatisch auf den neusten Stand der Anwendung gebracht werden.

Für den Produktiveinsatz heißt dass das auch hier alle Server auf Knopfdruck aktualisiert werden können und die Server einen definierten und bereits in QA getesten Zustand sind und bleiben. 

Um diese Ziele zu erreichen sind einige Veränderungen notwendig. In diesem Artikel möchten wir uns auf die notwendigen Änderungen im Entwicklungsprozess eingehen und wie wir diese mit Puppet umgesetzt haben.

\subsection{Puppet Einführung}

Puppet benutzt eine Domain-Specific-Language(DSL) um den Zustand eines System zu beschreiben. Der Code wird organisiert in Manifeste und Module.

Ein Manifest ist ein Puppet "Program". Module sind für die Puppet-EntwicklerIn ähnlich wie Libraries für eine Java-EntwicklerIn. Ein Großteil der Manifeste und Module mach die Definition von Ressourcen aus, eine Ressource ist ein atomarer Typ eines Systems, es entspricht einer physisches Identität eines Computersystems. Ein Beispiel für eine solche Ressource, wäre ein Benutzer oder eine Datei. In \reflst{puppet-add-user} wird der Ressource user \lstinline$puppetdemo$ und dazugehörige Ressource file \lstinline$/home/puppetdemo$ definiert. Der Aufruf \lstinline$sudo puppet apply manifest/user.pp$ führt es aus und muss mit 'sudo' aufgerufen werden damit Verzeichnis und Benutzer angelegt werden können.
Mit \lstinline$puppet resource user puppetdemo$ wird die Informationen zum neu angelegten Benutzer ausgegeben.\reflst{puppet-add-user-info}

\begin{lstlisting}[language=sh,caption=User mit Puppet anlegen, label=puppet-add-user]
$ cat manifest/user.pp 
node default {

    user {
        'puppetdemo' :
            ensure => present,
            home => '/home/puppetdemo',
            shell => '/bin/bash',
    }
    file {
        '/home/puppetdemo' :
        ensure => 'directory',
        owner => 'puppetdemo',
        group => 'puppetdemo',
    }
}
$ sudo puppet apply manifest/user.pp 
notice: /Stage[main]//Node[default]/User[puppetdemo]/ensure: created
notice: /Stage[main]//Node[default]/File[/home/puppetdemo]/ensure: created
notice: Finished catalog run in 0.36 seconds
\end{lstlisting}
\begin{lstlisting}[language=puppet,caption=Anzeige der Benutzerinformation in Puppet, label=puppet-add-user-info]
user { 'puppetdemo':
  ensure => present,
  gid    => '1004',
  home   => '/home/puppetdemo',
  shell  => '/bin/bash',
  uid    => '1002',
}
\end{lstlisting}

Eine Aufzählung der vom Puppet unterstützen Ressourcen wird mit \lstinline$puppet resource --types$ ausgegeben. Die Ressourcen sind im Core Types Cheat Sheet \url{http://docs.puppetlabs.com/puppet_core_types_cheatsheet.pdf} gut beschrieben.

%Im Beispiel\reffig{puppet-user}, sehen wir wie wir einen Benutzer und eine Datei mit der Puppet DSL anlegen.

%\begin{figure}
%  \begin{center}
%    \includegraphics[width=0.7\textwidth]{images/user.pdf}
%  \end{center}
%  \caption{User mit Puppet anlegen}
%  \label{puppet-user}
%\end{figure}


Für die Entwicklung von Puppet Module und Manifeste bietet sich \cite{geppeto} an. Geppeto bringt Code Completion und Syntax Highlighting mit und kommt als Standaloneapplikation oder als Plugin für eine bestehende Eclipseinstallation. 


%Der Manifest user.pp legen wir in einem Verzeichnis manifests ab\reffig{puppet-manifestdir}.

%\begin{figure}
%  \begin{center}
%    \includegraphics[width=0.7\textwidth]{images/manifestdir.pdf}
%  \end{center}
%  \caption{Puppet Manifest Verzeichnis}
%  \label{puppet-manifestdir}
%\end{figure}


\subsection{Testbox mit Vagrant}
Für die Entwicklung und Tests von Puppet Modulen und Manifeste empfielt sich eine virtuelle Machine. Puppet Labs stellt sollche für VMware und VirtualBox zur Verfügung unter \url{http://info.puppetlabs.com/download-learning-puppet-VM.html}. 

Eine andere Möglichkeit ist \cite{vagrant}. Vagrant ist eine Konfigurationstool für die Verwaltung von Virtuellen Maschinen mit VirtualBox. Es kann in weiterer Folge auch Puppet, Chef oder Shell Scripts benutzen kann um die virtuelle Maschine zu konfigurieren. Analog zu Virtualbox kann Vagrant via Paketmanager für Linux installiert werden oder von den entsprechenden Downloadseiten runtergeladen werden.Wir verwenden für diesen Artikel Vagrant. 

\begin{wrapfigure}{l}{5cm}
\vspace{-15pt}
\begin{boxedminipage}{5cm}
Eine Liste mit vorgefertigten Vagrant Boxen gibt es übrigens auf \url{http://www.vagrantbox.es/}
\end{boxedminipage}
\vspace{-15pt}
\end{wrapfigure}

Nachdem Vagrant und VirtualBox installiert worden sind, können wir eine Box zum Testen aufsetzen. In unserem Fall verwenden wir eine 64 Bit Version von Debian Squeeze. Diese wurde von uns für diesen Artikel neu erstellt und beinhaltet eine Minimalinstallation mit den für Vagrant üblichen Vorbereitungen: SSH Key Setup, VirtualBox Guest Additions, Puppet und Ruby. \url{http://vagrantup.com/v1/docs/base_boxes.html}

\begin{lstlisting}[language=sh,caption=Download der Vagrant Box, label=vagrant-add]
vagrant box add debian_squeeze_64 http://dl.dropbox.com/u/937870/VMs/squeeze64.box
\end{lstlisting}

\begin{wrapfigure}{r}{4.5cm}
\vspace{-20pt}
\begin{boxedminipage}{4.5cm}
 Die Vagrant Boxen werden unter Unix in installiert. \lstinline!$HOME/.vagrant.d/boxes!
Falls man dies ändern will kann man die Umgebungsvariable \lstinline$VAGRANT_HOME$ setzen:
\begin{lstlisting}[language=sh,label=vagrant-home,frame=none,numbers=none]
export VAGRANT_HOME=$HOME/vagrant_home
\end{lstlisting}
\end{boxedminipage}
\vspace{-20pt}
\end{wrapfigure}
 

Nachdem dem Download steht uns jetzt die  Vagrant Box \lstinline$debian_squeeze_64$ zur Verfügung. Nun können wir in ein beliebiges Verzeichnis wechsel und eine initiale Konfiguration basierend auf der Box anlegen\reflst{vagrant-init}.

\begin{lstlisting}[language=sh,caption=Vagrant initialisieren, label=vagrant-init]
vagrant init debian_squeeze_64
\end{lstlisting}

Diese initiale Konfiguration beinhaltet alles an was Vagrant zum Konfigurieren und Starten der Maschine braucht, es sind keine weiteren Einstellungen mehr nötig und wir können diese starten\reflst{vagrant-up}.

\begin{lstlisting}[language=sh,caption=Starten der Vagrant Maschine, label=vagrant-up]
vagrant up
\end{lstlisting}

Nachdem die virtuelle Machine gestartet worden ist, können wir mit ssh einsteigen\reflst{vagrant-ssh}. Unter Windows ist dieser Befehl derzeit nicht verfügbar und man muss deshalb mit Tools wie \cite{putty} darauf zugreifen.
\begin{lstlisting}[language=sh,caption=Mit ssh in der Vagrant Maschine einsteigen, label=vagrant-ssh]
vagrant ssh
\end{lstlisting}
 
Jetzt aktivieren wir die Puppetkonfiguration für unseren Vagrantbox. Vagrant liegt im Verzeichnis wo vagrant init durchgeführt haben, eine Datei Vagrantfile.
Öffne die Datei und lösche die Kommentarzeichen für die Sektion \lstinline$config.vm.provision :puppet$. Weiter tragen wir unter \lstinline$puppet.manifests_path$ und \lstinline$puppet.module_path$ ein wo Manifeste und Module liegen. Als \lstinline$puppet.manifest_file$ tragen wir \lstinline$user.pp$ ein. Zum testen von der Apacheinstallation wird mit \lstinline$config.vm.forward_port 80, 160$ Port 80 des Guests über Port 160 vom Host erreicht.
  
\begin{lstlisting}[language=vagrant,caption=Puppet Provisioning in Vagrantfile konfigurieren, label=vagrantprovisioning]
  config.vm.forward_port 80, 160  
  config.vm.provision :puppet do |puppet|
    puppet.manifests_path = "~/git/puppet-demo/puppet/manifests"
    puppet.module_path = "~/git/puppet-demo/puppet/modules"
    puppet.manifest_file  = "user.pp"
  end
\end{lstlisting} 

Bei dieser Änderung müssen wir den Box neu laden\reflst{vagrant-reload}. Der Puppet Manifest user.pp wir jetzt ausgeführt. Mit \lstinline$puppet ssh$ steigen wir und verifizieren dass der User 'puppetdemo' mit Home-Verzeichis /home/puppetdemo vorhanden ist

\begin{lstlisting}[language=sh,caption=Vagrant Box neu laden, label=vagrant-reload]
vagrant reload
notice: /Stage[main]//Node[default]/User[puppetdemo]/ensure: created
notice: /Stage[main]//Node[default]/File[/home/puppetdemo]/ensure: created
notice: Finished catalog run in 0.35 seconds

$ vagrant ssh
Welcome to your Vagrant-built virtual machine.

$ sudo su - puppetdemo
puppetdemo@precise32:~$ pwd
/home/puppetdemo
\end{lstlisting}

Mit \lstinline$vagrant provisioning$ kann der Puppet Manifest erneut ausgeführt werden. Ohne Änderungen im Manifest oder die virtuell Machine passiert nichts. Würde der Benutzer \lstinline$puppetdemo$ zum Beispiel entfernt, wird er wieder angelegt.
Will man der Puppet Manifest in der virtuellen Machine ausführen, ist der \lstinline$puppet.manifests_path$ als \lstinline$/tmp/vagrant-puppet/manifest$ gemounted\reflst{vagrant-apply}.

\begin{lstlisting}[language=sh,caption=Puppet apply im Box, label=vagrant-apply]
$ sudo puppet apply /tmp/vagrant-puppet/manifests/user.pp
No LSB modules are available.
notice: Finished catalog run in 0.04 seconds
$ sudo deluser puppetdemo
Removing user `puppetdemo' ...
Warning: group `puppetdemo' has no more members.
Done.
$ sudo puppet apply /tmp/vagrant-puppet/manifests/user.pp
No LSB modules are available.
notice: /Stage[main]//Node[default]/User[puppetdemo]/ensure: created
notice: Finished catalog run in 0.39 seconds
\end{lstlisting}

Der Vagrant-Box wird mit \lstinline$vagrant suspend$ angehalten, \lstinline$vagrant resume$ startet ihn wieder. Will man ganz von vorne anfagnen, entfernt \lstinline$vagrant destroy$ den Box. Die Datei Vagrantfile wird erhalten, damit kann man mit \lstinline$vagrant up$ den Box inklusive Provisioning mit Puppet wieder aufsetzen.

\section{Apache Webserver und Applikation mit HTML und JavaScript mit Puppet installieren}
Nachdem wir die Grundlagen von Puppet und Vagrant jetz gelernt haben, wird jetzt eine Apache Webserver installiert. Da es wahrscheinlich ist, dass Apache für andere Applikationen auch genutzt wird, wird der Puppet Code dafür in einem Module abgelegt. Module sind wiederverwendbare Einheiten vom Code und Data. Die Struktur eines Modules ist auf \url{http://docs.puppetlabs.com/learning/modules1.html} beschrieben\reffig{module_structure}. Siehe auch Puppet Module Cheat Sheet \url{docs.puppetlabs.com/module_cheat_sheet.pdf}.
\begin{figure}
  \begin{center}
    \includegraphics[width=0.7\textwidth]{images/module_structure.pdf}
  \end{center}
  \caption{Puppet Module Struktur}
  \label{module_structure}
\end{figure}


Auf die gleiche Ebene wie ders manifest-Verzeichnis legen wir \lstinline$modules$ an. Darunter \lstinline$apache/manifests/init.pp$\reflst{apache-module}.
\begin{lstlisting}[caption=Verzeichnisstruktur für den apache-Module, label=apache-module]
manifests/
modules/
  apache/
    manifests/
      init.pp
\end{lstlisting}

\lstinline$modules/apache/manifests/init.pp$ ist recht kompakt und zeigt auf einen Blick eine große Vorteil mit Puppet. Die Ressourcen \lstinline$package$ und \lstinline$service$ verstecken die Komplexität und platformspezifische Vorgen für Installation von Pakete und Starten von Dienste\reflst{apache-init.pp}.
\begin{lstlisting}[language=puppet,caption=Inhalt von modules/apache/manifests/init.pp, label=apache-init.pp]
class apache {
        package {
                'apache2' :
                        ensure => present,
        }
        service {
                'apache2' :
                        ensure => running,
                        require => Package["apache2"]
        }
}
\end{lstlisting}

Um der Module in einem Manifest zu verwenden reicht lediglich \lstinline$include apache$\reflst{setupapache.pp}.
\begin{lstlisting}[language=puppet,caption=Inhalt von manifests/setupapache.pp, label=setupapache.pp]
include apache
\end{lstlisting}

In Vagrantfile ändern wir jetzt die Zeile \lstinline$puppet.manifest_file  = "user.pp"$ auf \lstinline$puppet.manifest_file  = "setupapache.pp"$ und geben \lstinline$vagrant provision$ ein\reflst{provisioning_apache}.

\begin{lstlisting}[language=sh,caption=vagrant provisioning für Apache, label=provisioning_apache]
$ vagrant provision
[default] Running provisioner: Vagrant::Provisioners::Puppet...
[default] Running Puppet with /tmp/vagrant-puppet/manifests/setupapache.pp...
notice: /Stage[main]/Apache/Package[apache2]/ensure: ensure changed 'purged' to 'present'
notice: Finished catalog run in 97.25 seconds
\end{lstlisting}

\section*{Autoren}

\newcommand{\authorboxheight}{5cm}
\begin{minipage}[t][\authorboxheight]{0.45\textwidth}
\textbf{Anders Malmborg}
\vskip0.3cm
\begin{wrapfigure}{l}{0.3\textwidth}
\vspace{-20pt}
\includegraphics[width=0.3\textwidth]{images/anders.jpg}
\vspace{-20pt}
\end{wrapfigure}
hat jahrezehntelange Erfahrung in Applikations und Produktentwicklung im C++ und JavaEE  und arbeitet als IT Freelancer im automotive Bereich. 
\end{minipage}
\hspace{0.1\textwidth}
\begin{minipage}[t][\authorboxheight]{0.45\textwidth}
\textbf{Michael Haslgrübler}
\vskip0.3cm
\begin{wrapfigure}{l}{0.3\textwidth}
\vspace{-20pt}
\includegraphics[width=0.3\textwidth]{images/michael.jpg}
\vspace{-20pt}
\end{wrapfigure}
hat mehrjährige Erfahrung in JavaEE Entwicklungsumfeld in der Automotive und Immobilienbranche. Er administriert seit Jahren einen Linux-Root-Server für diverse Kunden.
\end{minipage}

\bibliographystyle{apalike2}
\bibliography{document}

\end{document}
